<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="utf-8">
    <title>Puzzle</title>
</head>

<body>
    <script type="module">
        import * as Phaser from 'https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.esm.js';

        const settings = {
            properties: {
                scoreVal: 10,
                myBallType: 'red',

                waves: [
                    { type: 'grimReaper', hp: 1200, duration: 60 },
                    { type: 'grimReaper', hp: 1500, duration: 60 },
                    { type: 'grimReaper', hp: 2000, duration: 60 },
                    { type: 'grimReaper', hp: 2500, duration: 60 },
                    { type: 'grimReaper', hp: 3000, duration: 90 },
                    { type: 'grimReaper', hp: 3500, duration: 90 },
                ],

                feverProps: {
                    feverMultiplier: 3, // ÂÄçÁéá
                    feverDuration: 5000, // ÁßíÊï∞
                    feverThreshold: 30, // ÂøÖË¶Å„Éú„Éº„É´Êï∞
                    feverTimeDuration: 3, // Êïµ„ÅÆÊôÇÈñì„ÅåÂª∂„Å≥„ÇãÔºàÁßíÊï∞Ôºâ
                }
            }
        }
        const data = settings.properties;

        const GAME_WIDTH = 300;
        const GAME_HEIGHT = 550;
        const UI_HEIGHT = 150;

        let score = 0; // „Çπ„Ç≥„Ç¢
        let myBallCount = 0; // My Ball

        class DragSelect {
            constructor(scene, group, offset = 5, triggerCount = 3) {
                this.scene = scene;
                this.group = group;
                this.offset = offset;
                this.active = false;
                this.selected = new Set();
                this.onReleaseCallback = null;
                this.triggerCount = triggerCount;

                scene.input.on('pointerdown', (pointer) => {
                    if (pointer.isDown) {
                        this.active = true;
                        this.selected.clear();
                    }
                });

                scene.input.on('pointerup', () => {
                    this.active = false;

                    if (this.graphics) {
                        this.graphics.clear();
                    }

                    if (this.onReleaseCallback) {
                        if (this.triggerCount === null || this.selected.size >= this.triggerCount) {
                            this.onReleaseCallback(this.selected);
                        }
                    }
                });
            }

            update() {
                if (!this.active || !this.scene.dragEnabled) return;

                const p = this.scene.input.activePointer;
                const selectedArray = [...this.selected];

                let last = selectedArray[selectedArray.length - 1];

                this.group.children.iterate(obj => {
                    if (obj.isJammer && !this.scene.purpleMode) return;
                    if (last?.isJammer && !this.scene.purpleMode) return;


                    const body = obj.body;
                    const x = body.position.x;
                    const y = body.position.y;
                    const radius = obj.displayWidth / 2;
                    const circle = new Phaser.Geom.Circle(x, y, radius);

                    if (!Phaser.Geom.Circle.Contains(circle, p.worldX, p.worldY)) return;

                    const indexInSelected = selectedArray.indexOf(obj);

                    if (indexInSelected !== -1) {
                        // ÈÅ∏ÊäûÊ∏à„Åø„ÅÆ„Éú„Éº„É´„Å´Êàª„Å£„ÅüÂ†¥Âêà„ÄÅ„Åù„ÅÆ„Éú„Éº„É´‰ª•Èôç„Çí„Åô„Åπ„Å¶ÈÅ∏ÊäûËß£Èô§
                        const toRemove = selectedArray.slice(indexInSelected + 1);
                        toRemove.forEach(ball => this.selected.delete(ball));
                        return;
                    }

                    if (this.selected.size === 0) {
                        this.selected.add(obj);

                        const pitch = 0.9 + this.selected.size * 0.02;
                        this.scene.sound.play('puni', {
                            rate: Phaser.Math.Clamp(pitch, 0.9, 1.2)
                        });

                        return;
                    }

                    // last „Å´ÂØæ„Åó„Å¶„ÅÆ„ÅøË∑ùÈõ¢Âà§ÂÆö
                    const dx = obj.x - last.x;
                    const dy = obj.y - last.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const threshold = (obj.displayWidth + last.displayWidth) / 2 + this.offset;

                    if (
                        distance <= threshold &&
                        (
                            this.scene.purpleMode ||
                            obj.type === last.type
                        )
                    ) {
                        this.selected.add(obj);

                        const pitch = 0.9 + this.selected.size * 0.02;
                        this.scene.sound.play('puni', {
                            rate: Phaser.Math.Clamp(pitch, 0.9, 1.2)
                        });

                    }
                });

                // --- „ÉÅ„Çß„Ç§„É≥„É©„Ç§„É≥ÊèèÁîª ---
                if (this.graphics) {
                    this.graphics.clear();

                    if (this.selected.size >= 2) {
                        this.graphics.lineStyle(2, 0xc6ecff, 0.9);

                        const points = [...this.selected];

                        this.graphics.fillStyle(0xc6ecff, 0.6);
                        points.forEach(p => {
                            this.graphics.fillCircle(p.x, p.y, 5);
                        });

                        this.graphics.beginPath();
                        this.graphics.moveTo(points[0].x, points[0].y);

                        for (let i = 1; i < points.length; i++) {
                            this.graphics.lineTo(points[i].x, points[i].y);
                        }

                        this.graphics.strokePath();
                    }
                }
            }

            onRelease(callback) {
                this.onReleaseCallback = callback;
            }
        }

        class Ball extends Phaser.Physics.Matter.Image {
            constructor(scene, x, y, type, scale = 0.9) {
                const textureKey = (type === 'jammer') ? 'item-oil' : 'ball-' + type;
                super(scene.matter.world, x, y, textureKey);
                scene.add.existing(this);

                this.type = type;
                this.isJammer = (type === 'jammer');

                const baseRadius = this.width / 2; // ÂÖÉÁîªÂÉè„Çµ„Ç§„Ç∫
                const radius = baseRadius * scale;

                // ‰∏∏„ÅÑÁâ©ÁêÜ„Éú„Éá„Ç£
                this.setScale(scale);
                this.setCircle(radius);
                this.setBounce(0.8);
                this.setFriction(0.01);
            }
        }

        class BombItem extends Phaser.Physics.Matter.Image {
            constructor(scene, x, y) {
                super(scene.matter.world, x, y, 'item-bomb');
                scene.add.existing(this);

                this.setScale(1.1);
                this.setCircle(this.displayWidth / 2);

                this.setBounce(0.8);
                this.setFriction(0.01);
                this.isItem = true;

                this.setInteractive({ useHandCursor: true });

                this.on('pointerdown', () => {
                    scene.explodeBomb(this);
                });
            }
        }

        class TimeItem extends Phaser.Physics.Matter.Image {
            constructor(scene, x, y, timeAmount = 5) {
                super(scene.matter.world, x, y, 'item-clock');
                scene.add.existing(this);

                this.setScale(1.1);
                this.setCircle(this.displayWidth / 2);

                this.setBounce(0.8);
                this.setFriction(0.01);
                this.timeAmount = timeAmount; // ËøΩÂä†ÊôÇÈñì

                this.setInteractive({ useHandCursor: true });

                this.on('pointerdown', () => {
                    scene.timeBomb(this.timeAmount); // „ÇØ„É™„ÉÉ„ÇØ„ÅßÊôÇÈñìËøΩÂä†
                    scene.itemGroup.remove(this, true, true);
                    this.destroy();
                });
            }
        }


        class Enemy extends Phaser.GameObjects.Image {
            constructor(scene, y, duration = 10) {
                super(scene, 0, y, 'enemy');

                this.scene = scene;
                this.maxHp = 100;
                this.hp = this.maxHp;

                this.laneStartX = 10;
                this.laneWidth = 220;
                this.laneEndX = this.laneStartX + this.laneWidth;

                this.duration = duration;      // ÈÄöÂ∏∏„ÅÆ‰∏äÈôêÊôÇÈñì
                this.elapsedTime = 0;
                this.allowOverTime = false;

                scene.add.existing(this);
            }

            damage(amount) {
                this.hp -= amount;
                if (this.hp <= 0) {
                    this.hp = 0;
                    this.scene.onEnemyDefeated(this);
                }
            }

            update(time, delta) {
                this.elapsedTime += delta / 1000;

                let progress = this.elapsedTime / this.duration;

                if (!this.allowOverTime) {
                    progress = Phaser.Math.Clamp(progress, 0, 1);
                }

                this.x = this.laneStartX + (this.laneEndX - this.laneStartX) * progress;
            }

            getRemainingTime() {
                return Math.max(0, this.duration - this.elapsedTime);
            }

            isTimeout() {
                if (this.allowOverTime) return false;
                return this.elapsedTime >= this.duration;
            }
        }


        class MainScene extends Phaser.Scene {
            constructor() {
                super({ key: 'MainScene' });
                this.dragEnabled = true;
            }

            preload() {
                // „Éú„Éº„É´ÁîªÂÉè
                this.load.image('ball-red', './img/hamburger-red.png');
                this.load.image('ball-blue', './img/hamburger-blue.png');
                this.load.image('ball-orange', './img/hamburger-orange.png');
                this.load.image('ball-purple', './img/hamburger-purple.png');
                this.load.image('enemy', './img/grimReaper.png');
                this.load.image('church', './img/church.png');
                this.load.image('item-bomb', './img/bomb.png');
                this.load.image('item-clock', './img/clock.png');
                this.load.image('item-oil', './img/oil.png');

                this.load.audio('puni', './sounds/puni.wav');
            }

            create() {
                this.gameOffsetY = UI_HEIGHT;

                this.myBallType = data.myBallType;
                this.myBallMax = 10;
                this.myBallGaugeFull = false;

                const width = 300;
                const height = 280;
                const offsetY = this.gameOffsetY;
                this.wallThickness = 20;

                // Â£Å„Å®Â∫ä„Çí Matter.js „ÅÆÈùôÁöÑ„Éú„Éá„Ç£„Å®„Åó„Å¶‰ΩúÊàê
                const wallColor = 0xfcba03;
                const roof = this.add.rectangle(width / 2, height - 120, width, this.wallThickness, wallColor);
                this.matter.add.gameObject(roof, { isStatic: true });
                const wallLeft = this.add.rectangle(this.wallThickness / 2, height / 2 + offsetY, this.wallThickness, height, wallColor);
                this.matter.add.gameObject(wallLeft, { isStatic: true });
                const wallRight = this.add.rectangle(width - this.wallThickness / 2, height / 2 + offsetY, this.wallThickness, height, wallColor);
                this.matter.add.gameObject(wallRight, { isStatic: true });
                const floor = this.add.rectangle(width / 2, height + offsetY, width, this.wallThickness, wallColor);
                this.matter.add.gameObject(floor, { isStatic: true });


                // For Tower Defense
                this.add.rectangle(100, 75, 225, 150, 0xada6a6);
                this.add.rectangle(260, 75, 85, 150, 0xada6a6);
                this.add.image(260, 75, 'church');
                this.timeCircle = this.add.circle(150, 180, 24)
                    .setStrokeStyle(2, 0x000000)
                    .setFillStyle(0xffffff, 0);

                this.timeLimitText = this.add.text(150, 180, '10', {
                    fontSize: '24px',
                    color: '#ffffff',
                    stroke: '#000',
                    strokeThickness: 2,
                }).setOrigin(0.5);


                this.enemyHpText = this.add.text(10, 125, '', {
                    fontSize: '14px',
                    fill: '#ff5656',
                    backgroundColor: '#fff',
                    padding: {
                        x: 6,
                        y: 4
                    }
                });

                this.scoreText = this.add.text(10, 10, '', { fontSize: '16px', fill: '#000', backgroundColor: '#fff' });


                // My Ball UI
                this.myBallGaugeX = 50;
                this.myBallGaugeY = 500;
                this.myBallGaugeRadius = 22;

                this.myBallIcon = this.add.image(
                    this.myBallGaugeX,
                    this.myBallGaugeY,
                    'ball-' + this.myBallType
                );
                this.myBallIcon.setScale(0.7).setDepth(2).setAlpha(0.95);

                // My Ball Icon „Çí„ÇØ„É™„ÉÉ„ÇØÂèØËÉΩ„Å´
                this.myBallIcon.setInteractive({ useHandCursor: true });
                this.myBallIcon.on('pointerdown', () => {
                    this.useMyBallItem();
                });


                this.myBallGaugeBg = this.add.graphics();
                this.myBallGaugeBg.lineStyle(4, 0x444444, 1);
                this.myBallGaugeBg.strokeCircle(
                    this.myBallGaugeX,
                    this.myBallGaugeY,
                    this.myBallGaugeRadius
                );

                this.myBallGauge = this.add.graphics();

                // „Éï„Ç£„Éº„Éê„ÉºUI

                this.feverGaugeX = 80;
                this.feverGaugeY = 470;
                this.feverGaugeWidth = 160;
                this.feverGaugeHeight = 12;

                this.feverGaugeBg = this.add.rectangle(
                    this.feverGaugeX,
                    this.feverGaugeY,
                    this.feverGaugeWidth,
                    this.feverGaugeHeight,
                    0x444444
                ).setOrigin(0, 0.5);

                this.feverGauge = this.add.rectangle(
                    this.feverGaugeX,
                    this.feverGaugeY,
                    0,
                    this.feverGaugeHeight,
                    0xff5555
                ).setOrigin(0, 0.5);

                this.add.text(
                    this.feverGaugeX - 50,
                    this.feverGaugeY,
                    'FEVER',
                    { fontSize: '12px', color: '#ffffff' }
                ).setOrigin(0, 0.5);

                // „Éï„Ç£„Éº„Éê„ÉºÁî®„Éï„É≠„ÉºÔºà‰∏ä„Å´Ë¢´„Åõ„ÇãÔºâ
                this.feverFlow = this.add.rectangle(
                    this.feverGaugeX,
                    this.feverGaugeY,
                    30,
                    this.feverGaugeHeight,
                    0xffffff,
                    0.35
                ).setOrigin(0, 0.5);

                this.feverFlow.visible = false;




                // UIÂàùÊúüÂåñ
                this.updateUI();


                const buttonWidth = 40;
                const buttonHeight = 40;
                const shuffleButtonWrapper = this.add.rectangle(
                    width - buttonWidth / 2 - 10,  // Âè≥Á´Ø„Åã„ÇâÂ∞ë„ÅóÂÜÖÂÅ¥
                    height - buttonHeight / 2 - 10 + offsetY, // ‰∏ãÁ´Ø„Åã„ÇâÂ∞ë„ÅóÂÜÖÂÅ¥
                    buttonWidth,
                    buttonHeight,
                    wallColor // „Éú„Çø„É≥„ÅÆËâ≤
                );
                this.matter.add.gameObject(shuffleButtonWrapper, { isStatic: true });

                // „Éú„Éº„É´ÁîüÊàê
                this.balls = [];
                this.ballGroup = this.add.group();
                this.spawnBalls(50, 1, 0, 2); // ÊúÄÂàù„Å´50ÂÄãÁîüÊàê

                // „ÉÅ„Çß„Ç§„É≥ÁîüÊàê
                this.chainGraphics = this.add.graphics();
                this.chainGraphics.setDepth(10);


                // Ball„Ç¢„Éì„É™„ÉÜ„Ç£Á≥ª
                this.purpleMode = false;


                // WaveÁ≥ª
                this.currentWaveIndex = 0;
                this.waves = data.waves;


                // ScoreÁ≥ª
                this.canScore = true;
                this.isCleared = false;




                this.feverActive = false;
                this.feverMultiplier = data.feverProps.feverMultiplier;
                this.feverDuration = data.feverProps.feverDuration;
                this.feverCounter = 0;
                this.feverThreshold = data.feverProps.feverThreshold;
                this.feverTimer = null;


                this.dragSelect = new DragSelect(this, this.ballGroup);
                this.dragSelect.graphics = this.chainGraphics;

                this.dragSelect.onRelease((selected) => {
                    if (this.isCleared) return;

                    const array = [...selected]; // Set ‚Üí ÈÖçÂàó

                    let last = array[array.length - 1];
                    let lastPos = last ? { x: last.x, y: last.y } : null;
                    const previousBallCount = array.length;

                    const damage = array.length * data.scoreVal * (this.feverActive ? this.feverMultiplier : 1);

                    const destroyedCount = array.length;

                    if (!this.feverActive) {
                        this.feverCounter += destroyedCount;
                        this.updateFeverGauge();
                    }

                    array.forEach((ball, i) => {
                        this.time.delayedCall(150 * i, () => {
                            if (ball.isJammer && !this.purpleMode) return;
                            if (this.isCleared) return;

                            if (ball.type === this.myBallType) {
                                myBallCount++;
                                this.updateUI();
                            }

                            this.ballGroup.remove(ball, true, true);
                            ball.destroy();

                            if (i === array.length - 1) {
                                if (previousBallCount >= 6 && lastPos) {
                                    const item = new BombItem(this, lastPos.x, lastPos.y);
                                    this.itemGroup.add(item);
                                }
                                this.spawnBalls(array.length);
                            }
                        }, null, this);
                    });

                    if (this.canScore) {
                        score += damage;
                        this.updateUI();
                    }

                    const enemy = this.enemyGroup.getChildren()[0];
                    if (enemy) {
                        enemy.damage(damage);
                    }


                    this.dragSelect.selected.clear();
                });

                this.lastClickTime = 0;

                const shuffleButton = this.add.text(250, 250 + offsetY, 'üåÄ', { font: '32px Arial', fill: '#ffffff' })
                    .setInteractive({ useHandCursor: true }) // „ÇØ„É™„ÉÉ„ÇØÂèØËÉΩ„Å´„Åô„Çã
                    .on('pointerdown', () => {
                        const now = this.time.now; // ÁèæÂú®„ÅÆÊôÇÈñìÔºàmsÔºâ
                        const interval = 5000;      // „Ç§„É≥„Çø„Éº„Éê„É´ 500ms = 0.5Áßí

                        if (now - this.lastClickTime >= interval) {
                            this.lastClickTime = now;
                            this.shuffleBalls(); // ÂÆüÈöõ„ÅÆÂá¶ÁêÜ
                        }
                    });

                this.enemyGroup = this.add.group();

                this.spawnEnemy();

                this.itemGroup = this.add.group();
            }

            updateUI() {
                this.scoreText.setText(`Score: ${score}`);
                this.updateMyBallGauge();
            }

            update(time, delta) {
                this.dragSelect.update();

                this.ballGroup.children.iterate(ball => {
                    if (this.dragSelect.selected.has(ball)) {
                        ball.setTint(0x88ccff);
                    } else {
                        ball.clearTint();
                    }
                })

                const enemies = this.enemyGroup.getChildren();

                if (enemies.length === 0) {
                    return;
                }

                if (enemies.length > 0) {
                    const enemy = enemies[0]; // ‰ªä„ÅØ1‰Ωì„Å†„ÅëÊÉ≥ÂÆö
                    enemy.update(time, delta);

                    if (!this.jammerSpawned && enemy.hp < enemy.maxHp * 0.7) {
                        this.spawnJammer(2);
                        this.jammerSpawned = true;
                    }

                    const remain = enemy.getRemainingTime();
                    this.timeLimitText.setText(
                        `${remain.toFixed()}`
                    );

                    this.enemyHpText.setText(
                        `Enemy HP: ${Math.max(0, enemy.hp)}`
                    );

                    // ÊôÇÈñìÂàá„Çå„Åß„Ç≤„Éº„É†„Ç™„Éº„Éê„Éº
                    if (enemy.isTimeout()) {
                        this.enemyGroup.remove(enemy, true, true);

                        // GAME OVER „ÉÜ„Ç≠„Çπ„Éà
                        this.showGameOverText();
                    }
                }

                if (!this.feverActive && this.feverCounter >= this.feverThreshold) {
                    this.startFever();
                }
            }

            // ‰ªªÊÑè„ÅÆÊï∞„ÅÆ„Éú„Éº„É´„ÇíÁîüÊàê„Åó„Å¶„Ç∞„É´„Éº„Éó„Å´ËøΩÂä†„Åô„ÇãÈñ¢Êï∞
            spawnBalls(count = 20, defaultScale = 0.9, uniqueBall = 0, uniqueSize = 1.5) {
                const wallThickness = this.wallThickness;
                const offsetY = this.gameOffsetY;
                const width = 300;
                const height = 300;
                const types = ['red', 'blue', 'orange', 'purple'];

                for (let i = 0; i < count; i++) {
                    const type = types[Phaser.Math.Between(0, types.length - 1)];
                    const x = Phaser.Math.Between(wallThickness + 25, width - wallThickness - 25);
                    const y = Phaser.Math.Between(25 + offsetY, height / 2 + offsetY);

                    const scale = i < uniqueBall ? uniqueSize : defaultScale;
                    const ball = new Ball(this, x, y, type, scale);

                    ball.setInteractive();

                    ball.on('pointerdown', () => {
                        if (!this.purpleMode) return;
                        this.destroySingleBall(ball);
                    });

                    this.balls.push(ball);
                    this.ballGroup.add(ball);
                }
            }

            shuffleBalls() {
                const balls = this.ballGroup.getChildren(); // ÂÖ®„Éú„Éº„É´ÂèñÂæó

                balls.forEach(ball => {
                    // ‰∏äÊñπÂêë„Éô„ÇØ„Éà„É´ + „É©„É≥„ÉÄ„É†Ê®™„Éô„ÇØ„Éà„É´
                    const vx = Phaser.Math.Between(-10, 10); // Â∑¶Âè≥„Å´„É©„É≥„ÉÄ„É†
                    const vy = Phaser.Math.Between(-10, -6); // ‰∏äÊñπÂêë
                    ball.setVelocity(vx, vy);
                });
            }

            explodeBomb(item) {
                if (this.isCleared) return;

                if (item.exploded) return; // ‚òÖ ‰∫åÈáçËµ∑ÁàÜÈò≤Ê≠¢
                item.exploded = true;

                const radius = 40;
                const balls = this.ballGroup.getChildren();
                const items = this.itemGroup.getChildren();

                let deletedCount = 0;

                // --- „Éú„Éº„É´Á†¥Â£ä ---
                balls.forEach(ball => {
                    if (this.isCleared) return;
                    const dx = ball.x - item.x;
                    const dy = ball.y - item.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist <= radius) {
                        if (ball.type === this.myBallType) {
                            myBallCount++;
                        }

                        this.ballGroup.remove(ball, true, true);
                        ball.destroy();
                        deletedCount++;
                    }
                });

                if (!this.feverActive) {
                    this.feverCounter += deletedCount;
                    this.updateFeverGauge();
                }

                // --- „ÉÄ„É°„Éº„Ç∏Ë®àÁÆó ---
                const damage = deletedCount * data.scoreVal;

                const bonusTable = {
                    1: 1.0,
                    2: 1.1,
                    3: 1.25,
                    4: 1.4,
                    5: 1.6,
                    6: 2.0
                };

                const bonus = bonusTable[deletedCount] ?? 1.0;
                const scoreGain = Math.floor(damage * bonus);
                score += scoreGain;
                this.updateUI();

                // --- Êïµ„ÉÄ„É°„Éº„Ç∏ ---
                const enemy = this.enemyGroup.getChildren()[0];
                if (enemy) {
                    enemy.damage(damage);
                }

                // --- Ë£úÂÖÖ ---
                this.spawnBalls(deletedCount);

                // --- üí£ ‰ªñ„ÅÆÁàÜÂºæ„ÇíËµ∑ÁàÜ ---
                items.forEach(other => {
                    if (other === item) return;
                    if (other.exploded) return;

                    const dx = other.x - item.x;
                    const dy = other.y - item.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist <= radius) {
                        // Â∞ë„ÅóÈÅÖ„Çâ„Åõ„Çã„Å®ÂÆâÂÖ®
                        this.time.delayedCall(0, () => {
                            this.explodeBomb(other);
                        });
                    }
                });

                // --- ÊºîÂá∫ ---
                this.cameras.main.shake(200, 0.015);

                // --- Ëá™ÂàÜ„ÇíÊ∂à„Åô ---
                this.itemGroup.remove(item, true, true);
                item.destroy();
            }

            timeBomb(extraTime) {
                const enemy = this.enemyGroup.getChildren()[0];
                if (enemy) {
                    enemy.duration += extraTime;
                    this.updateUI();
                }
            }

            resizeBall(ball, newScale) {
                const baseRadius = ball.width / 2;
                const radius = baseRadius * newScale;

                ball.setScale(newScale);

                // Áâ©ÁêÜ„Éú„Éá„Ç£„Çí‰Ωú„ÇäÁõ¥„Åô
                ball.setCircle(radius);
            }

            // Ëâ≤„ÅßÂÖ®ÈÅ∏Êäû: this.selectByType('red');
            selectByType(type) {
                this.dragSelect.selected.clear();

                this.ballGroup.children.iterate(ball => {
                    if (ball.type === type) {
                        this.dragSelect.selected.add(ball);
                    }
                })
            }

            updateMyBallGauge() {
                const ratio = Phaser.Math.Clamp(
                    myBallCount / this.myBallMax,
                    0,
                    1
                );

                this.myBallGauge.clear();

                this.myBallGauge.lineStyle(4, 0xffcc00, 1);
                this.myBallGauge.beginPath();

                // -90Â∫¶„Çπ„Çø„Éº„ÉàÔºà‰∏ä„Åã„ÇâÔºâ
                this.myBallGauge.arc(
                    this.myBallGaugeX,
                    this.myBallGaugeY,
                    this.myBallGaugeRadius,
                    Phaser.Math.DegToRad(-90),
                    Phaser.Math.DegToRad(-90 + 360 * ratio),
                    false
                );

                this.myBallGauge.strokePath();

                // „Ç≤„Éº„Ç∏Max„Åß„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
                if (ratio >= 1 && !this.myBallGaugeFull) {
                    this.myBallGaugeFull = true;
                    this.playMyBallFullAnimation();
                }

                // ‚òÖ Ê∏õ„Å£„Åü„Çâ„É™„Çª„ÉÉ„Éà
                if (ratio < 1) {
                    this.myBallGaugeFull = false;
                }
            }

            updateMyBallIcon() {
                this.myBallIcon.setTexture('ball-' + this.myBallType);
            }

            playMyBallFullAnimation() {

                // „Ç≤„Éº„Ç∏Ê≥¢Á¥ã
                const ring = this.add.circle(
                    this.myBallGaugeX,
                    this.myBallGaugeY,
                    this.myBallGaugeRadius,
                    0xffcc00,
                    0
                ).setStrokeStyle(3, 0xffcc00);

                this.tweens.add({
                    targets: ring,
                    scale: 1.6,
                    alpha: 0,
                    duration: 500,
                    ease: 'Cubic.Out',
                    onComplete: () => ring.destroy()
                });

                // „Ç¢„Ç§„Ç≥„É≥„Éù„ÉÉ„Éó
                this.tweens.add({
                    targets: this.myBallIcon,
                    scale: 0.85,
                    yoyo: true,
                    duration: 120,
                    repeat: 1,
                    ease: 'Back.Out'
                });
            }

            useMyBallItem() {
                if (!this.myBallGaugeFull) return; // „Éï„É´„Åò„ÇÉ„Å™„Åë„Çå„Å∞‰Ωï„ÇÇ„Åó„Å™„ÅÑ

                // ÂäπÊûú„Çí„Éú„Éº„É´„Çø„Ç§„Éó„Åî„Å®„Å´Âàá„ÇäÊõø„Åà
                const effects = {
                    red: () => {
                        const bomb = new BombItem(this, 150, 300);
                        this.itemGroup.add(bomb);
                    },
                    blue: () => {
                        const timeItem = new TimeItem(this, 150, 300, 5);
                        this.itemGroup.add(timeItem);
                    },
                    orange: () => {
                        this.selectByType('orange');

                        const ds = this.dragSelect;
                        const old = ds.triggerCount;
                        ds.triggerCount = null;

                        // pointerup „ÇíÂÅΩË£Ö
                        ds.onReleaseCallback(ds.selected);

                        ds.triggerCount = old;
                        ds.selected.clear();
                    },
                    purple: () => {
                        this.purpleMode = true;

                        this.cameras.main.flash(100, 180, 120, 255);

                        this.time.delayedCall(3000, () => {
                            this.purpleMode = false;
                        })
                    }
                };

                const effect = effects[this.myBallType];
                if (effect) effect();

                myBallCount -= this.myBallMax;
                if (myBallCount < 0) myBallCount = 0;

                this.myBallGaugeFull = false;
                this.updateMyBallGauge();
            }


            destroySingleBall(ball) {
                if (this.isCleared) return;
                if (!ball.active) return;
                if (ball.isJammer && !this.purpleMode) return;

                // „Ç´„Ç¶„É≥„ÉàÁ≥ª
                if (!this.feverActive) {
                    this.feverCounter += 1;
                    this.updateFeverGauge();
                }

                if (ball.type === this.myBallType) {
                    myBallCount++;
                }

                // „Çπ„Ç≥„Ç¢
                const damage = data.scoreVal *
                    (this.feverActive ? this.feverMultiplier : 1);

                if (this.canScore) {
                    score += damage;
                    this.updateUI();
                }

                // Êïµ„ÉÄ„É°„Éº„Ç∏
                const enemy = this.enemyGroup.getChildren()[0];
                if (enemy) enemy.damage(damage);

                // Á†¥Â£ä
                this.ballGroup.remove(ball, true, true);
                ball.destroy();

                // Ë£úÂÖÖ
                this.spawnBalls(1);
            }


            spawnJammer(count = 1) {
                const wallThickness = this.wallThickness;
                const offsetY = this.gameOffsetY;
                const width = 300;

                this.cameras.main.shake(100, 0.005);
                this.sound.play('puni', { rate: 0.6 });

                for (let i = 0; i < count; i++) {
                    const x = Phaser.Math.Between(wallThickness + 25, width - wallThickness - 25);
                    const y = Phaser.Math.Between(25 + offsetY, 80 + offsetY);

                    const jammer = new Ball(this, x, y, 'jammer', 1.0);
                    jammer.setTexture('item-oil');
                    jammer.isJammer = true;

                    jammer.setInteractive();
                    jammer.on('pointerdown', () => {
                        if (!this.purpleMode) return;
                        this.destroySingleBall(jammer);
                    });

                    this.ballGroup.add(jammer);
                }
            }

            // „Éï„Ç£„Éº„Éê„Éº
            startFever() {
                if (this.feverActive) return; // ‰∫åÈáçÁô∫ÂãïÈò≤Ê≠¢Ôºà‰øùÈô∫Ôºâ

                this.feverActive = true;
                this.feverCounter = 0;
                this.updateFeverGauge();

                const enemy = this.enemyGroup.getChildren()[0];
                if (enemy)
                    enemy.duration += data.feverProps.feverTimeDuration;

                // „Ç≤„Éº„Ç∏„ÇíÊ∫Ä„Çø„É≥„Å´
                this.feverGauge.width = this.feverGaugeWidth;
                this.feverGauge.setFillStyle(0xffdd55);

                // „Éï„É≠„ÉºË°®Á§∫
                this.feverFlow.visible = true;
                this.feverFlow.x = this.feverGaugeX - 30;

                // Êó¢Â≠òTweenÂÅúÊ≠¢
                this.tweens.killTweensOf(this.feverFlow);

                // Ê®™„Å´ÊµÅ„Åô
                this.tweens.add({
                    targets: this.feverFlow,
                    x: this.feverGaugeX + this.feverGaugeWidth,
                    duration: 600,
                    repeat: -1,
                    ease: 'Linear'
                });


                // ÁîªÈù¢„Éï„É©„ÉÉ„Ç∑„É•Áî®„Ç™„Éº„Éê„Éº„É¨„Ç§
                const flash = this.add.rectangle(
                    GAME_WIDTH / 2,
                    GAME_HEIGHT / 2,
                    GAME_WIDTH,
                    GAME_HEIGHT,
                    0xffffff,
                    1
                ).setDepth(1000);

                this.tweens.add({
                    targets: flash,
                    alpha: 0,
                    duration: 120,
                    ease: 'Quad.Out',
                    onComplete: () => flash.destroy()
                });


                // Êó¢Â≠òTween„ÇíÂøµ„ÅÆ„Åü„ÇÅÂÅúÊ≠¢
                this.tweens.killTweensOf(this.feverGauge);

                // ÁÇπÊªÖÊºîÂá∫
                this.tweens.add({
                    targets: this.feverGauge,
                    alpha: 0.3,
                    yoyo: true,
                    repeat: -1,
                    duration: 200
                });

                if (this.feverTimer) {
                    this.time.removeEvent(this.feverTimer);
                }

                this.feverTimer = this.time.delayedCall(
                    this.feverDuration,
                    () => {
                        this.feverActive = false;
                        this.feverGauge.alpha = 1;
                        this.tweens.killTweensOf(this.feverGauge);
                        this.feverFlow.visible = false;
                        this.tweens.killTweensOf(this.feverFlow);
                        this.updateFeverGauge(); // ÈÄöÂ∏∏Ëâ≤„Å´Êàª„Åô
                    }
                );
            }


            updateFeverGauge() {
                const ratio = Phaser.Math.Clamp(
                    this.feverCounter / this.feverThreshold,
                    0,
                    1
                );

                this.feverGauge.width = this.feverGaugeWidth * ratio;

                // „Éï„Ç£„Éº„Éê„Éº‰∏≠ÊºîÂá∫
                if (this.feverActive) {
                    this.feverGauge.setFillStyle(0xffdd55);
                } else {
                    this.feverGauge.setFillStyle(0xff5555);
                }
            }


            // EnemyÁ≥ª
            spawnEnemy() {
                // ÂÖ®„Ç¶„Çß„Éº„ÉñÁµÇ‰∫Ü„Åß„É™„Çπ„Çø„Éº„Éà
                if (this.currentWaveIndex >= this.waves.length) {
                    this.showClearText();
                    this.time.delayedCall(5000, () => {
                        this.scene.restart();
                    })
                    return;
                }

                this.showWaveText(this.currentWaveIndex + 1); // Wave„ÉÜ„Ç≠„Çπ„ÉàË°®Á§∫

                const waveData = this.waves[this.currentWaveIndex];
                const enemy = new Enemy(this, 75, waveData.duration);
                enemy.maxHp = waveData.hp;
                enemy.hp = waveData.hp;
                this.enemyGroup.add(enemy);
            }

            onEnemyDefeated(enemy) {
                this.dragEnabled = false;
                this.enemyGroup.remove(enemy, true, true);
                this.enemyHpText.setText('Enemy HP: 0');
                this.timeLimitText.setText('');


                if (this.currentWaveIndex >= this.waves.length) {
                    this.isCleared = true;
                    this.showClearText();
                    return;
                }

                this.canScore = false;

                this.currentWaveIndex++;

                this.time.delayedCall(2000, () => {
                    this.canScore = true;
                    this.spawnEnemy();
                    this.dragEnabled = true;
                });
            }

            showWaveText(waveNumber) {
                const text = this.add.text(
                    this.cameras.main.centerX,
                    this.cameras.main.centerY,
                    `Wave ${waveNumber}`,
                    {
                        fontSize: '32px',
                        color: '#ffffff',
                        fontStyle: 'bold',
                        stroke: '#000000',
                        strokeThickness: 4
                    }
                ).setOrigin(0.5).setAlpha(0).setScale(0.8);

                // „Éï„Çß„Éº„Éâ„Ç§„É≥
                this.tweens.add({
                    targets: text,
                    alpha: 1,
                    scale: 1.2,
                    duration: 400,
                    ease: 'Cubic.Out',
                    onComplete: () => {
                        // Â∞ë„ÅóÊ≠¢„ÇÅ„Çã
                        this.time.delayedCall(400, () => {
                            // „Éï„Çß„Éº„Éâ„Ç¢„Ç¶„Éà
                            this.tweens.add({
                                targets: text,
                                alpha: 0,
                                scale: 0.8,
                                duration: 400,
                                ease: 'Cubic.In',
                                onComplete: () => text.destroy()
                            });
                        });
                    }
                });
            }

            showClearText() {
                this.isCleared = true;
                const text = this.add.text(
                    this.cameras.main.centerX,
                    this.cameras.main.centerY,
                    'CLEAR!!',
                    {
                        fontSize: '32px',
                        color: '#ffff66',
                        fontStyle: 'bold',
                        stroke: '#ff6600',
                        strokeThickness: 6
                    }
                ).setOrigin(0.5).setAlpha(0).setScale(0.5);

                // Êã°Â§ß„Åó„Å™„Åå„Çâ„Éï„Çß„Éº„Éâ„Ç§„É≥
                this.tweens.add({
                    targets: text,
                    alpha: 1,
                    scale: 1.2,
                    duration: 500,
                    ease: 'Back.Out',
                    onComplete: () => {
                        // Â∞ë„ÅóÊ≠¢„ÇÅ„Çã
                        this.time.delayedCall(800, () => {
                            // „Éï„Çß„Éº„Éâ„Ç¢„Ç¶„Éà
                            this.tweens.add({
                                targets: text,
                                alpha: 0,
                                scale: 1.5,
                                duration: 500,
                                ease: 'Cubic.In',
                                onComplete: () => {
                                    const finalScore = score;
                                    text.destroy();
                                    score = 0;
                                    myBallCount = 0;
                                    this.time.delayedCall(500, () => {
                                        this.scene.start('ClearScene', { score: finalScore });
                                    });
                                }
                            });
                        });
                    }
                });
            }

            showGameOverText() {
                const text = this.add.text(
                    this.cameras.main.centerX,
                    this.cameras.main.centerY,
                    'GAME OVER',
                    {
                        fontSize: '32px',
                        color: '#ff4444',
                        fontStyle: 'bold',
                        stroke: '#000000',
                        strokeThickness: 6
                    }
                ).setOrigin(0.5).setAlpha(0).setScale(0.5);

                // „Éï„Çß„Éº„Éâ„Ç§„É≥ÔºÜÊã°Â§ß
                this.tweens.add({
                    targets: text,
                    alpha: 1,
                    scale: 1.2,
                    duration: 500,
                    ease: 'Back.Out',
                    onComplete: () => {
                        this.time.delayedCall(500, () => {
                            const finalScore = score;
                            text.destroy();
                            score = 0;
                            myBallCount = 0;
                            this.time.delayedCall(500, () => {
                                this.scene.start('GameOverScene', { score: finalScore });
                            });
                        });
                    }
                });
            }

        }


        class TitleScene extends Phaser.Scene {
            constructor() {
                super({ key: 'TitleScene' });
            }

            preload() {
                this.load.image('ball-red', './img/hamburger-red.png');
                this.load.image('ball-blue', './img/hamburger-blue.png');
                this.load.image('ball-orange', './img/hamburger-orange.png');
                this.load.image('ball-purple', './img/hamburger-purple.png');
                this.load.image('button', './img/button.png'); // ‰ªªÊÑè„ÅÆ„Éú„Çø„É≥ÁîªÂÉè
            }

            create() {
                this.selectedBall = 'red'; // ÂàùÊúüÂÄ§

                // „Çø„Ç§„Éà„É´„ÉÜ„Ç≠„Çπ„Éà
                this.add.text(150, 150, 'Ball√óBall', {
                    fontSize: '32px',
                    color: '#ffffff'
                }).setOrigin(0.5);

                // Ball„Çª„É¨„ÇØ„ÉàÁî®„Éú„Çø„É≥ÔºàÁîªÂÉè„Çí„ÇØ„É™„ÉÉ„ÇØ„ÅßÈÅ∏ÊäûÔºâ
                const types = ['red', 'blue', 'orange', 'purple'];
                this.selectedBall = 'red';
                types.forEach((type, index) => {
                    const ball = this.add.image(80 + index * 50, 250, 'ball-' + type)
                        .setInteractive({ useHandCursor: true })
                        .setScale(0.8);

                    ball.on('pointerdown', () => {
                        this.selectedBall = type;
                        // ÈÅ∏ÊäûË¶ñË¶öÂåñ
                        types.forEach(t => {
                            const b = this.children.getByName(t);
                            if (b) b.setTint(t === type ? 0xffffff : 0x846301);
                        });
                    });

                    ball.setName(type);
                });

                // BattleÈñãÂßã„Éú„Çø„É≥
                const button = this.add.text(155, 350, 'Battle Start', {
                    fontSize: '24px',
                    backgroundColor: '#fcba03',
                    color: '#ffffff',
                    padding: { x: 10, y: 5 }
                }).setOrigin(0.5)
                    .setInteractive({ useHandCursor: true });

                button.on('pointerdown', () => {
                    // ÈÅ∏Êäû„Åó„Åü„Éú„Éº„É´„Çí global „Å´Ê∏°„Åô
                    settings.properties.myBallType = this.selectedBall;

                    // MainScene „Å´Âàá„ÇäÊõø„Åà
                    this.scene.start('MainScene');
                });
            }
        }


        class ClearScene extends Phaser.Scene {
            constructor() {
                super({ key: 'ClearScene' });
            }

            init(data) {
                this.finalScore = data.score || 0; // MainScene „Åã„Çâ„Çπ„Ç≥„Ç¢„ÇíÂèó„ÅëÂèñ„Çã
            }

            create() {
                const centerX = this.cameras.main.centerX;
                const centerY = this.cameras.main.centerY;

                // ËÉåÊôØ
                this.add.rectangle(centerX, centerY, 300, 550, 0x222222);

                // "CLEAR!!" „ÉÜ„Ç≠„Çπ„Éà
                this.add.text(centerX, centerY - 100, 'CLEAR!!', {
                    fontSize: '48px',
                    color: '#ffff66',
                    fontStyle: 'bold',
                    stroke: '#ff6600',
                    strokeThickness: 6
                }).setOrigin(0.5);

                // „Çπ„Ç≥„Ç¢Ë°®Á§∫
                this.add.text(centerX, centerY, `Score: ${this.finalScore}`, {
                    fontSize: '32px',
                    color: '#ffffff'
                }).setOrigin(0.5);

                // „Çø„Ç§„Éà„É´„Å´Êàª„Çã„Éú„Çø„É≥
                const button = this.add.text(centerX, centerY + 100, '„Çø„Ç§„Éà„É´„Å´Êàª„Çã', {
                    fontSize: '24px',
                    backgroundColor: '#fcba03',
                    color: '#000000',
                    padding: { x: 10, y: 5 }
                }).setOrigin(0.5)
                    .setInteractive({ useHandCursor: true });

                button.on('pointerdown', () => {
                    this.scene.start('TitleScene');
                });
            }
        }

        class GameOverScene extends Phaser.Scene {
            constructor() {
                super({ key: 'GameOverScene' });
            }

            init(data) {
                this.finalScore = data.score || 0;
            }

            create() {
                const centerX = this.cameras.main.centerX;
                const centerY = this.cameras.main.centerY;

                // ËÉåÊôØ
                this.add.rectangle(centerX, centerY, 300, 550, 0x222222);

                // "GAME OVER" „ÉÜ„Ç≠„Çπ„Éà
                this.add.text(centerX, centerY - 100, 'GAME OVER', {
                    fontSize: '48px',
                    color: '#ff4444',
                    fontStyle: 'bold',
                    stroke: '#000000',
                    strokeThickness: 6
                }).setOrigin(0.5);

                // „Çπ„Ç≥„Ç¢Ë°®Á§∫
                this.add.text(centerX, centerY, `Score: ${this.finalScore}`, {
                    fontSize: '32px',
                    color: '#ffffff'
                }).setOrigin(0.5);

                // „Çø„Ç§„Éà„É´„Å´Êàª„Çã„Éú„Çø„É≥
                const button = this.add.text(centerX, centerY + 100, '„Çø„Ç§„Éà„É´„Å´Êàª„Çã', {
                    fontSize: '24px',
                    backgroundColor: '#fcba03',
                    color: '#000000',
                    padding: { x: 10, y: 5 }
                }).setOrigin(0.5)
                    .setInteractive({ useHandCursor: true });

                button.on('pointerdown', () => {
                    this.scene.start('TitleScene');
                });
            }
        }




        new Phaser.Game({
            type: Phaser.AUTO,

            width: GAME_WIDTH,
            height: GAME_HEIGHT,
            backgroundColor: "#3b3a3d",

            resolution: window.devicePixelRatio,

            scale: {
                mode: Phaser.Scale.FIT,
                autoCenter: Phaser.Scale.CENTER_BOTH,
            },

            scene: [TitleScene, MainScene, ClearScene, GameOverScene],

            physics: {
                default: 'matter',
                matter: {
                    gravity: { y: 1 },
                    debug: false
                }
            }
        });
    </script>
</body>

</html>